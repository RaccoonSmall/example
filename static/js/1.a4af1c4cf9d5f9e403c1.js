webpackJsonp([1],{"5jmt":function(t,n){},Fprs:function(t,n,e){"use strict";var s={render:function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("main",[t._m(0),t._v(" "),e("div",[e("p",[t._v("Store Action 异步操作实例用应用")]),t._v(" "),e("div",{staticClass:"x-font-container"},[t._v("在程序应用中，避免不了异步的接口的调用处理。当组件之间的状态需要改变其形态时，需要做网络请求时来执行对状态更改，此时我们在Action 中执行异步请求，提交Mutation的处理。")]),t._v(" "),e("p",[t._v("  this.$store.dispatch() 返回的时Promise对象，因此我门就可以明确异步请求什么时候结束了以及是否抛出异常。如何你对Promise 还不熟悉，那么示例对于你来说就”黯然失色“，建议先去熟悉Promise 的概念以及使用。当然在某些情况，异步操作我们可以直接在Vue Methods 中处理，然后store.commit(); 更加好的方式在对于组件状态更改时，必须在Action 中做分发提交对状态的更改。")]),t._v(" "),e("strong",{staticClass:"x-btn",on:{click:t.actionDispatch}},[t._v("触发Action 使用this.$store.dispatch('actionB')")]),e("br")])])},staticRenderFns:[function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",[e("p",{staticClass:"title-tip margin-t-0"},[t._v("使用进阶--Action")]),t._v(" "),e("div",{staticClass:"x-font-container"},[t._v("Action 类似与Mutation。 但是需要注意的是，不同于有以下两点：\n            "),e("p",{staticClass:"color-red"},[t._v("1、Mutation 是同步操作,而Action是处理异步的操作")]),t._v(" "),e("p",{staticClass:"color-red"},[t._v("2、Mutation 是变更Store State状态，而Action 是用来显式的提交Mutation--commit()")]),t._v(" "),e("strong",[t._v("不同于mutations，触发actions，使用this.$store.dispatch() 方法")])]),t._v(" "),e("pre",[t._v("            "),e("div",[t._v("action 接收一个具有Store 对象相同的context 对象。因此我们可以通过context.commit() 显式的提交Mutation. 或者获取Store State、Getter：【context.state】对象，【context.getters】对象")]),t._v("\n            "),e("code",[t._v("\n                const store = new vuex.Store({\n                    state:{\n                        status:'0',\n                    },\n                    getters:{\n                        userName(state,getter){\n                            return '小明'\n                        }\n                    },\n                    mutations:{\n                        setStatus(state,data) {\n                            state.status = '1';\n                        },\n                    },\n                    // Action 作用：显式的提交Mutation,异步逻辑的操作\n                    actions:{\n                        insertUser(context) {\n                            let status = context.state.status;\n                            let name = context.getters.userName;\n                            context.commit('setStatus');\n                        }\n                    }\n                });\n            ")]),t._v("\n        ")])])}]};n.a=s},T6y6:function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var s=e("oCKM"),o=e.n(s);for(var i in s)"default"!==i&&function(t){e.d(n,t,function(){return s[t]})}(i);var a=e("Fprs");var c=function(t){e("5jmt")},r=e("VU/8")(o.a,a.a,!1,c,"data-v-8cd41f3c",null);n.default=r.exports},oCKM:function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default={data:function(){return{}},methods:{actionDispatch:function(){this.$store.dispatch("actionB")}}}}});
//# sourceMappingURL=1.a4af1c4cf9d5f9e403c1.js.map